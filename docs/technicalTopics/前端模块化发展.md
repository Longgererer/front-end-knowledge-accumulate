# 前端模块化发展

有开发经验的同学应该很明白模块化对于代码可读性和可维护性的好处，这里就不多说了，我们在这里说说前端模块化的发展历程。

## 闭包

闭包函数是典型的模块化解决方案，有效的防止了全局变量污染，可维护性等一系列问题。早期的许多库，如 JQuery 都是使用类似的形式来避免代码中定义的变量污染全局。

IIFE(自执行函数)+闭包也是最早的模块化形式：

```javascript
const obj = (function() {
  let a = 1
  return {
    getA: () => a,
    setA: (newA) => {
      a = newA
    },
  }
})()
console.log(obj.a) // undefined
console.log(obj.getA()) // 1
obj.setA(5)
console.log(obj.getA()) // 5
```

在上面的代码中，我们定义了对象 `obj`，通过暴露 `set` 和 `get` 方法来对内部变量 `a` 进行处理，外部无法直接访问到 `a`，这就是闭包的优势。

但它的缺点显而易见：如果一个闭包里面需要用到另一个闭包里的东西该怎么办？也许我们会这样做：

```javascript
;(function() {
  const $ = (target) => document.querySelector(target)
  window.$ = $
})()
;(function() {
  const div = window.$('div')
})()
```

通过这种方式我们成功的通过 `window` 将 `$` 共享至另一个闭包中，可如果偶然其他闭包中也在 `window` 上定义了 `$`，这个方法可就行不通了。因此 `IIFE` 并不能完美的解决模块化问题。

## CommonJS

CommonJS 就像它的名字一样将模块“公共化”了，CommonJS 规范如下：

- 一个 js 文件就是一个模块
- 每个模块有单独的作用域
- 通过 `module.exports` 导出成员
- 通过 `require` 函数载入模块

```javascript
const module1 = require('./module1.js')
module.exports = {
  a: 1,
}
```

CommonJS 有两个问题：浏览器不理解它。其次，加载模块是同步进行的，这也许会产生不好的体验。

为了在浏览器上实现 CommonJS，可以使用一些模块化打包方案如 Webpack。

在 Node 上，CommonJS 大放异彩，Node 在 CommonJS 的基础上进行了一些修改，增加了一些特性，同时也催生了 `npm`。

## AMD & CMD

为了解决 CommonJS 规范在浏览器端的不足，AMD 诞生了。RequireJS 就是其中的代表。

AMD 定义了 `define` 方法来定义和加载模块。

```javascript
// 声明模块名及其位置
require.config({
  paths: {
    module1: 'libs/module1',
    module2: 'libs/module2',
  },
})

// 定义模块
define(function() {
  return module3
})

// 在模块中引入其他模块
define(['module1', 'module2'], function(m1, m2) {
  return module3
})

// 引入模块并使用
require(['module1', 'module2'], function(m1, m2) {
  // ...
})
```

AMD 的模块加载是异步的，也是浏览器所采用的规范。

CMD 专门用于浏览器，模块异步加载且在使用的时候才会加载，代表作 SeaJS。

```javascript
//定义没有依赖的模块
define(function(require, exports, module) {
  exports.xxx = value
  module.exports = value
})

//定义有依赖的模块
define(function(require, exports, module) {
  //引入依赖模块(同步)
  var module2 = require('./module2')
  //引入依赖模块(异步)
  require.async('./module3', function(m3) {})
  //暴露模块
  exports.xxx = value
})

//引入使用模块
define(function(require) {
  var m1 = require('./module1')
  var m4 = require('./module4')
  m1.show()
  m4.show()
})
```

### AMD 和 CMD 的区别

- 对于依赖的模块，AMD 会提前执行，CMD 会延迟执行。
- AMD 的 API 一个当多个用，职责单一。CMD 将 API 细分，各司其职。

## ESM(ES modules)

**👉 重点！敲黑板 👈**

ESM 是现代浏览器的最佳实践，现在 Node 也支持 ESM 了。

ESM 的默认导入导出：

```javascript
// 导出
const obj = { a: 1 }
export default obj
// 导入，导入模块名是自定义的
import m1 from './module1.js'
// 上面这个是下面的缩写
import { default as m1 } from './module1.js'
```

有选择地导出多个：

```javascript
// 导出
export const a = 1
export const b = 2
export const c = 3
// 上面两句等价于下面
// const a = 1
// const b = 2
// const c = 3
// export { a, b, c }

// 导入，模块名称要一致
import { a, b, c } from './module.js'
// 选择性导入
import { a, b } from './module.js'
// 将a命名为d并导入
import { a as d, b, c } from './module.js'
```

`export` 的时候也可以为模块定义别名：

```javascript
export { a as d }
```

如果导入的模块太多，觉得乱，可以将这些模块全部导入到一个对象上：

```javascript
import * as module1 from './module1.js'
```

### import()

`import` 导入的模块是静态的，在代码加载的时候就被编译了，这样会降低页面加载速度。

可以使用 `import` 函数来按需加载模块，`import` 函数是异步的，这和 `require` 不同。

```javascript
// 执行a的时候才会加载模块
async function a() {
  let module = await import('/modules/my-module.js')
}
```

### 在浏览器中使用

想要在浏览器中使用 ESM，引入的时候要在 `script` 标签定义一个 `type='module'`：

```javascript
<script type="module" src="./index.js"></script>
```

## 参考文章

- [JavaScript Modules: From IIFEs to CommonJS to ES6 Modules](https://ui.dev/javascript-modules-iifes-commonjs-esmodules/)
- [五分钟带你回顾前端模块化发展史](https://segmentfault.com/a/1190000021952509)
- [前端工程化 — 模块化开发](https://zhuanlan.zhihu.com/p/346476124)
- [图说 ES Modules](https://segmentfault.com/a/1190000014318751)