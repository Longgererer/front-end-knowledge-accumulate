# 浏览器渲染原理

## 浏览器渲染流程

首先，浏览器在渲染页面之前需要先构建**DOM**(文档对象模型)树和**CSSOM**(CSS 对象模型)树，然后将 DOM 和 CSSOM 这两个树合并成一个**渲染**树，浏览器通过 Render 树计算每个节点的信息，最终将各个节点绘制到屏幕上。

### DOM 和 CSSOM 怎么来的

事实上浏览器通过网络接收到的不过是一长串比特而已，如何将其构建成对象模型呢？

构建 DOM 和 CSSOM 的步骤分为五步：

Bytes(字节) ➡ Characters(字符) ➡ Tokens(令牌) ➡ Nodes(节点) ➡ DOM/CSSOM(对象模型)

:::tip Notice
DOM 和 CSSDOM 是**独立的数据结构**，因此这两个树不是一起生成的，但生成这两个树的步骤是相同的！
:::

有下面一段代码，看看浏览器是如何转化的：

```html
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link href="style.css" rel="stylesheet" />
    <title>Critical Path</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg" /></div>
  </body>
</html>
```

用一幅图解释转化的五个步骤：

<a data-fancybox title="full-process.png" href="http://picstore.lliiooiill.cn/koeVZtuDaNKHSAB.png">![full-process.png](http://picstore.lliiooiill.cn/koeVZtuDaNKHSAB.png)</a>

1. **字节转换为字符**：浏览器从磁盘或网络读取 HTML 原始字节，并根据文件的指定编码(如 UTF-8)将他们转换成各个字符
2. **令牌化**：浏览器将字符转换成 W3C HTML5 规定的各种令牌，每一个令牌都有特殊的含义和规则。
3. **词法分析**：将令牌转化成包含其属性和规则的对象
4. **DOM 构建**：将词法分析后生成的对象生成一个树形结构

如果没有为页面中的元素赋予样式，浏览器会赋予每个元素默认的样式(User Agent)。

但是通常页面中都会包含 link 或 style 标签，因此浏览器需要将 CSS 字节通过上面五个步骤转换成 CSSOM 树，如下图所示：

<a data-fancybox title="cssom-tree.png" href="http://picstore.lliiooiill.cn/fHj39VD7N2ox86w.png">![cssom-tree.png](http://picstore.lliiooiill.cn/fHj39VD7N2ox86w.png)</a>

### 渲染树

知道了 DOM 和 CSSOM 是如何生成的还不够，因为这不是最终的数据，浏览器还会把这两个树合并成一个渲染树。

渲染树**只包含了渲染网页所需的节点**，如果这个元素样式设置为`display:none`或`<head></head>`这种不可见的标签是不包含在渲染树中的。

:::tip Notice
`visibility：hidden` 虽然不可见，但该元素仍然占据页面的一部分，所以它包含在渲染树中
:::

浏览器会计算渲染树里每一个元素的 layout(布局)，也可以叫做回流，一般情况下仅需执行一次流处理方法便可以计算所有元素的布局(对于 table 元素需要计算多次)

## 阻塞渲染

默认情况下，CSS 被视为阻塞渲染的资源，在 CSSOM 树构建完毕之前，浏览器不会渲染任何内容。

我们常常使用 link 标签引入外部样式，这就会导致渲染阻塞，浏览器会优先处理这些资源，如果网络较慢，很可能会出现一段时间的白屏

在适配设备的时候，我们常常用到媒体类型或媒体查询，为不同的设备匹配不同的样式，这个时候我们不需要一次性将所有样式全部引入：

```html
<link href="style.css" rel="stylesheet" />
<link href="print.css" rel="stylesheet" media="print" />
<link href="other.css" rel="stylesheet" media="(min-width: 40em)" />
```

如上面代码所示，第一个样式是默认引入的，它始终会阻塞渲染；第二个样式只有在打印的时候才会引入，页面初始加载的时候不会阻塞渲染；第三个样式表明浏览器执行的媒体查询符合条件的时候才会阻塞渲染。

除了 style 和 link，JS 同样可以修改样式，因此 JS 文件或 inline JS 的加载同样会阻塞 DOM 和 CSSOM 的 构建，进而阻塞渲染。

script 脚本在 html 文档中的位置十分重要，HTML 解析器解析到 script 脚本便会暂停 DOM 的构建，将控制权移交给 JavaScript 引擎直到脚本完成执行，再进行 DOM 构建，这延缓了页面的首次渲染。

如果 CSSOM 的构建过程中遇到了 script 脚本，并不会中断 CSSOM 的构建，这是因为 script 可以更改样式，也就是说 script 是可以访问 CSSOM 的，因此**必须在构建完成 CSSOM 的情况下再执行 script**。

如果 JS 文件中，没有对 DOM 节点及其样式进行操作，可以将 script 声明为异步以避免阻塞：

```javascript
<script src="app.js" async></script>
```

## 回流和重绘

### 回流

当渲染树中**部分或全部元素尺寸，结构或某些属性发生过改变时**，浏览器重新渲染部分或全部文档的过程称为回流。

会导致回流的操作如下：

- 页面首次渲染。
- 浏览器窗口大小发生改变。
- 元素尺寸或位置发生改变。
- 元素内容变化（文字数量或图片大小等等）。
- 元素字体大小变化。
- 添加或者删除**可见**的 DOM 元素。
- 激活 CSS 伪类（例如：`:hover`）。
- 查询某些属性或调用某些方法。

还有一些会导致回流的属性和方法：

- `clientWidth`、`clientHeight`、`clientTop`、`clientLeft`。
- `offsetWidth`、`offsetHeight`、`offsetTop`、`offsetLeft`。
- `scrollWidth`、`scrollHeight`、`scrollTop`、`scrollLeft`。
- `scrollIntoView()`、`scrollIntoViewIfNeeded()`。
- `getComputedStyle()`。
- `getBoundingClientRect()`。
- `scrollTo()`。

### 重绘

当页面中元素样式的改变并不影响它在文档流中的位置时（例如：`color`、`background-color`、`visibility` 等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

### 浏览器所做的优化

浏览器会维护一个渲染队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。

当你访问以下属性或方法时，浏览器会立刻清空队列：

- `clientWidth`、`clientHeight`、`clientTop`、`clientLeft`。
- `offsetWidth`、`offsetHeight`、`offsetTop`、`offsetLeft`。
- `scrollWidth`、`scrollHeight`、`scrollTop`、`scrollLeft`。
- `width`、`height`。
- `getComputedStyle()`。
- `getBoundingClientRect()`。

因为队列中**可能会有影响到这些属性或方法返回值的操作**，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。

### css3 硬件加速（GPU 加速）

使用 css3 硬件加速，可以让 `transform`、`opacity`、`filters` 这些动画不会引起回流重绘。

对于动画的其它属性，比如 `background-color` 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

## 渲染层合并

渲染层合并(Composite layouts)发生在回流与重绘之后，对**页面中 DOM 元素的绘制是在多个层上进行的**。

在 DOM 树中每个节点都会对应一个 LayoutObject，当他们的 LayoutObject 处于相同的坐标空间时，就会形成一个 RenderLayers ，也就是渲染层。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。

某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer(图形层)，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层共用一个。

满足下列任意情况，元素将会获得自己的层：

- 3D 或透视变换(perspective transform) CSS 属性。
- 使用加速视频解码的 `<video>` 元素 拥有 3D。
- (WebGL) 上下文或加速的 2D 上下文的 `<canvas>` 元素。
- 混合插件(如 Flash)。
- 对自己的 `opacity` 做 CSS 动画或使用一个动画变换的元素。
- 拥有加速 CSS 过滤器的元素。
- 元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)。
- 元素有一个 `z-index` 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)。

一旦 RenderLayer 提升为了合成层就会有自己的绘图上下文，并且会开启硬件加速，有利于性能提升。

元素提升为合成层后，`transform` 和 `opacity` 才不会触发重绘，如果不是合成层，则其依然会触发重绘。

在 Blink 和 WebKit 内核的浏览器中，对于应用了 `transition` 或者 `animation` 的 `opacity` 元素，浏览器会将渲染层提升为合成层。也可以使用 `translateZ(0)` 或者 `translate3d(0,0,0)` 来人为地强制性地创建一个合成层。

## 如何优化渲染速度

### 减少页面首次渲染

1. **使用 async 或 defer 将一些不必要的 script 延迟执行**

```javascript
<script src="app1.js" async></script>
<script src="app2.js" defer></script>
```

使用 `async` 可以将脚本延迟执行(仅适用于外部脚本)，但注意：如果引入了多个异步脚本，不要认为这些脚本会按照加载的顺序执行，顺序是随机的。

`defer` 属性如果是多个脚本，可以确保脚本按照加载顺序执行。

`defer` 和 `async` 的区别在于脚本需要等到完全被加载和解析完成之后 (`DOMContentLoaded` 事件被触发前)执行，而 `async` 脚本的执行和文档解析是同步的，当然，这只是在 `script` 脚本下载的时候不会阻塞 DOM 构建，在代码执行的时候照样会阻塞，看看这张图就可以彻底明白了：

<a data-fancybox title="2151798436-59da4801c6772_articlex.png" href="http://picstore.lliiooiill.cn/vwGgFS7WPO9iNJy.png">![2151798436-59da4801c6772_articlex.png](http://picstore.lliiooiill.cn/vwGgFS7WPO9iNJy.png)</a>

2. **如果 css 涉及到屏幕适配，在 link 标签内添加媒体查询以避免引入不必要的样式**

```html
<link href="style.css" rel="stylesheet" />
<link href="print.css" rel="stylesheet" media="print" />
<link href="other.css" rel="stylesheet" media="(min-width: 40em)" />
```

3. **降低 CSS 选择器的复杂性**

不要过多的使用伪类：

```css
.box:nth-last-child(-n + 1) .title {
  /* styles */
}
```

浏览器在解析的时候需要询问：“是否有一个 `title` 类元素，它的父元素正好是负第 N+1 个并且类名为 `box` 的元素”，应该知道的是：要想知道元素是否为最后一个元素，必须先知道其他元素的所有情况，如果可以使用一个类名或者 `id` 代替，就不要使用过于这些复杂的伪类，浏览器可能要花大量的时间去计算。

### 减少回流和重绘

- 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流(改变了布局)。
- 不要频繁的设置节点 `style` 属性值(因为这会涉及到计算，所以会引发回流)。
- 不要使用 `table` 布局，可能很小的一个小改动会造成整个 `table` 的重新布局(对于 `table`，可能要进行多次计算才能够完成布局)。
- CSS 选择符从右往左匹配查找，避免节点层级过多。
- 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 `requestAnimationFrame`。
- 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 `video` 标签来说，浏览器会自动将该节点变为图层。

当我们需要对 DOM 做一系列修改的时候，可以通过以下步骤减少回流次数：

1. 使元素**脱离文档流**。
2. 对其进行多次修改。
3. 将元素带回到文档中。

该过程的第一和第三步可能会引发回流，但第二步，在元素已经脱离文档流的情况下，对 DOM 的所有修改都不会引起回流重绘，因为它已经不在渲染树了。

有三种方式使元素脱离文档流：

- 隐藏元素，应用修改，重新显示。
- 使用文档片段(document fragment)在当前 DOM 之外构建一个子树，再把它拷贝回文档。
- 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。

对于复杂的动画效果，我们可以为元素设置 `absolute/fixed` 定位来让其脱离文档流。

### 浏览器对渲染的优化

浏览器本身会尽可能地减少回流和重绘的次数，只更改必要的元素。比如 `absolute/fixed positioned` 元素的大小更改仅仅影响元素本身及其后代，而 `static` 元素的更改会触发所有后续元素的回流。

在执行一段 js 代码时，浏览器会缓存所做的更改，并在代码运行后一次通过这些更改：

```javascript
var $body = $('body')
$body.css('padding', '1px') // 回流，重绘
$body.css('color', 'red') // 重绘
$body.css('margin', '2px') // 回流，重绘
```

浏览器不会在每次改变样式的时候就进行重绘和回流，而是在代码执行后，因此只会执行一次回流和重绘。

在下面这种情况下浏览器会进行两次回流：

```javascript
var $body = $('body')
$body.css('padding', '1px')
$body.css('padding') // 读取元素属性，触发强制回流
$body.css('color', 'red')
$body.css('margin', '2px')
```

在获取元素 `padding` 属性的时候，浏览器需要进行一次回流以保证数值的精确性，我们其实可以利用这个特性实现一些功能。

定义如下两个 `div`：

```html
<div id="div1" class="transition"></div>
<div id="div2" class="transition"></div>
```

定义样式：

```css
div {
  width: 100px;
  height: 50px;
  background-color: cornflowerblue;
  margin-top: 10px;
}
.transition {
  transition: width 0.5s ease;
}
```

然后为两个 `div` 添加鼠标移入移出事件：

```javascript
const $ = (str) => document.querySelector(str)
$('#div1').onmouseenter = function() {
  this.className = ''
  this.style.width = '150px'
  this.className = 'transition'
  this.style.width = '80px'
  this.onmouseleave = function() {
    this.style.width = '100px'
  }
}
$('#div2').onmouseenter = function() {
  this.className = ''
  this.style.width = '150px'
  console.log(this.offsetHeight) // 获取offsetHeight，出发强制回流
  this.className = 'transition'
  this.style.width = '80px'
  this.onmouseleave = function() {
    this.style.width = '100px'
  }
}
```

效果如图：

<a data-fancybox title="GIF.gif" href="http://picstore.lliiooiill.cn/EqWjL2Ki8wUrmpG.gif">![GIF.gif](http://picstore.lliiooiill.cn/EqWjL2Ki8wUrmpG.gif)</a>

我们可以看到 `div2` 由于触发了强制回流，浏览器将 `width = '150px'` 效果渲染了出来，而 `div1` 则没有。

## 参考文章

- [浏览器的渲染：过程与原理](https://zhuanlan.zhihu.com/p/29418126)
- [渲染树构建、布局及绘制](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn)
- [What Every Frontend Developer Should Know About Webpage Rendering](http://frontendbabel.info/articles/webpage-rendering-101/)
- [深入浅出浏览器渲染原理](https://zhuanlan.zhihu.com/p/53913989)
- [浏览器的回流与重绘 (Reflow & Repaint)](https://juejin.cn/post/6844903569087266823)
- [你真的了解回流和重绘吗](https://juejin.cn/post/6844903779700047885)
- [Webkit 渲染基础与硬件加速](https://segmentfault.com/a/1190000013627093)