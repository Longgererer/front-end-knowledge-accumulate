# 浏览器渲染原理

## 浏览器渲染流程

首先，浏览器在渲染页面之前需要先构建**DOM**(文档对象模型)树和**CSSOM**(CSS 对象模型)树，然后将 DOM 和 CSSOM 这两个树合并成一个**渲染**树，浏览器通过 Render 树计算每个节点的信息，最终将各个节点绘制到屏幕上。

### DOM 和 CSSOM 怎么来的

事实上浏览器通过网络接收到的不过是一长串比特而已，如何将其构建成对象模型呢？

构建 DOM 和 CSSOM 的步骤分为五步：

Bytes(字节) ➡ Characters(字符) ➡ Tokens(令牌) ➡ Nodes(节点) ➡ DOM/CSSOM(对象模型)

:::tip Notice
DOM 和 CSSDOM 是**独立的数据结构**，因此这两个树不是一起生成的，但生成这两个树的步骤是相同的！
:::

有下面一段代码，看看浏览器是如何转化的：

```html
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link href="style.css" rel="stylesheet" />
    <title>Critical Path</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg" /></div>
  </body>
</html>
```

用一幅图解释转化的五个步骤：

![full-process.png](http://picstore.lliiooiill.cn/koeVZtuDaNKHSAB.png)

1. **字节转换为字符**：浏览器从磁盘或网络读取 HTML 原始字节，并根据文件的指定编码(如 UTF-8)将他们转换成各个字符
2. **令牌化**：浏览器将字符转换成 W3C HTML5 规定的各种令牌，每一个令牌都有特殊的含义和规则。
3. **词法分析**：将令牌转化成包含其属性和规则的对象
4. **DOM 构建**：将词法分析后生成的对象生成一个树形结构

如果没有为页面中的元素赋予样式，浏览器会赋予每个元素默认的样式(User Agent)。

但是通常页面中都会包含 link 或 style 标签，因此浏览器需要将 CSS 字节通过上面五个步骤转换成 CSSOM 树，如下图所示：

![cssom-tree.png](http://picstore.lliiooiill.cn/fHj39VD7N2ox86w.png)

### 渲染树

知道了 DOM 和 CSSOM 是如何生成的还不够，因为这不是最终的数据，浏览器还会把这两个树合并成一个渲染树。

渲染树**只包含了渲染网页所需的节点**，如果这个元素样式设置为`display:none`或`<head></head>`这种不可见的标签是不包含在渲染树中的。

:::tip Notice
`visibility：hidden` 虽然不可见，但该元素仍然占据页面的一部分，所以它包含在渲染树中
:::

浏览器会计算渲染树里每一个元素的 layout(布局)，也可以叫做回流，一般情况下仅需执行一次流处理方法便可以计算所有元素的布局(对于 table 元素需要计算多次)

## 阻塞渲染

默认情况下，CSS 被视为阻塞渲染的资源，在 CSSOM 树构建完毕之前，浏览器不会渲染任何内容。

我们常常使用 link 标签引入外部样式，这就会导致渲染阻塞，浏览器会优先处理这些资源，如果网络较慢，很可能会出现一段时间的白屏

在适配设备的时候，我们常常用到媒体类型或媒体查询，为不同的设备匹配不同的样式，这个时候我们不需要一次性将所有样式全部引入：

```html
<link href="style.css" rel="stylesheet" />
<link href="print.css" rel="stylesheet" media="print" />
<link href="other.css" rel="stylesheet" media="(min-width: 40em)" />
```

如上面代码所示，第一个样式是默认引入的，它始终会阻塞渲染；第二个样式只有在打印的时候才会引入，页面初始加载的时候不会阻塞渲染；第三个样式表明浏览器执行的媒体查询符合条件的时候才会阻塞渲染。

除了 style 和 link，JS 同样可以修改样式，因此 JS 文件或 inline JS 的加载同样会阻塞 DOM 和 CSSOM 的 构建，进而阻塞渲染。

script 脚本在 html 文档中的位置十分重要，HTML 解析器解析到 script 脚本便会暂停 DOM 的构建，将控制权移交给 JavaScript 引擎直到脚本完成执行，再进行 DOM 构建，这延缓了页面的首次渲染。

如果 CSSOM 的构建过程中遇到了 script 脚本，并不会中断 CSSOM 的构建，这是因为 script 可以更改样式，也就是说 script 是可以访问 CSSOM 的，因此**必须在构建完成 CSSOM 的情况下再执行 script**。

如果 JS 文件中，没有对 DOM 节点及其样式进行操作，可以将 script 声明为异步以避免阻塞：

```javascript
<script src="app.js" async></script>
```

## 如何优化渲染速度

### 减少页面首次渲染

1. **使用 async 或 defer 将一些不必要的 script 延迟执行**

```javascript
<script src="app1.js" async></script>
<script src="app2.js" defer></script>
```

使用 async 可以将脚本延迟执行(仅适用于外部脚本)，但注意：如果引入了多个异步脚本，不要认为这些脚本会按照加载的顺序执行，顺序是随机的。

defer 属性如果是多个脚本，可以确保脚本按照加载顺序执行。

defer 和 async 的区别在于脚本需要等到完全被加载和解析完成之后 (`DOMContentLoaded` 事件被触发前)执行，而 async 脚本的执行和文档解析是同步的，当然，这只是在 script 脚本下载的时候不会阻塞 DOM 构建，在代码执行的时候照样会阻塞，看看这张图就可以彻底明白了：

![2151798436-59da4801c6772_articlex.png](http://picstore.lliiooiill.cn/vwGgFS7WPO9iNJy.png)

2. **如果 css 涉及到屏幕适配，在 link 标签内添加媒体查询以避免引入不必要的样式**

```html
<link href="style.css" rel="stylesheet" />
<link href="print.css" rel="stylesheet" media="print" />
<link href="other.css" rel="stylesheet" media="(min-width: 40em)" />
```

3. **降低 CSS 选择器的复杂性**

不要过多的使用伪类：

```css
.box:nth-last-child(-n + 1) .title {
  /* styles */
}
```

浏览器在解析的时候需要询问：“是否有一个 title 类元素，它的父元素正好是负第 N+1 个并且类名为 box 的元素”，应该知道的是：要想知道元素是否为最后一个元素，必须先知道其他元素的所有情况，如果可以使用一个类名或者 id 代替，就不要使用过于这些复杂的伪类，浏览器可能要花大量的时间去计算。

### 减少回流和重绘

- 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流(改变了布局)
- 不要频繁的设置节点 style 属性值(因为这会涉及到计算，所以会引发回流)
- 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局(对于 table，可能要进行多次计算才能够完成布局)
- CSS 选择符从右往左匹配查找，避免节点层级过多
- 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame
- 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层

### 浏览器对渲染的优化

浏览器本身会尽可能地减少回流和重绘的次数，只更改必要的元素。比如 `absolute/fixed positioned` 元素的大小更改仅仅影响元素本身及其后代，而 `static` 元素的更改会触发所有后续元素的回流。

在执行一段 js 代码时，浏览器会缓存所做的更改，并在代码运行后一次通过这些更改：

```javascript
var $body = $('body')
$body.css('padding', '1px') // 回流，重绘
$body.css('color', 'red') // 重绘
$body.css('margin', '2px') // 回流，重绘
```

浏览器不会在每次改变样式的时候就进行重绘和回流，而是在代码执行后，因此只会执行一次回流和重绘。

在下面这种情况下浏览器会进行两次回流：

```javascript
var $body = $('body')
$body.css('padding', '1px')
$body.css('padding') // 读取元素属性，触发强制回流
$body.css('color', 'red')
$body.css('margin', '2px')
```

在获取元素 padding 属性的时候，浏览器需要进行一次回流以保证数值的精确性，我们其实可以利用这个特性实现一些功能。

定义如下两个 div：

```html
<div id="div1" class="transition"></div>
<div id="div2" class="transition"></div>
```

定义样式：

```css
div {
  width: 100px;
  height: 50px;
  background-color: cornflowerblue;
  margin-top: 10px;
}
.transition {
  transition: width 0.5s ease;
}
```

然后为两个 div 添加鼠标移入移出事件：

```javascript
const $ = (str) => document.querySelector(str)
$('#div1').onmouseenter = function () {
  this.className = ''
  this.style.width = '150px'
  this.className = 'transition'
  this.style.width = '80px'
  this.onmouseleave = function () {
    this.style.width = '100px'
  }
}
$('#div2').onmouseenter = function () {
  this.className = ''
  this.style.width = '150px'
  console.log(this.offsetHeight) // 获取offsetHeight，出发强制回流
  this.className = 'transition'
  this.style.width = '80px'
  this.onmouseleave = function () {
    this.style.width = '100px'
  }
}
```

效果如图：

![GIF.gif](http://picstore.lliiooiill.cn/EqWjL2Ki8wUrmpG.gif)

我们可以看到 div2 由于触发了强制回流，浏览器将 `width = '150px'` 效果渲染了出来，而 div1 则没有。

## 参考文章

- [浏览器的渲染：过程与原理](https://zhuanlan.zhihu.com/p/29418126)
- [渲染树构建、布局及绘制](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn)
- [What Every Frontend Developer Should Know About Webpage Rendering](http://frontendbabel.info/articles/webpage-rendering-101/)
- [深入浅出浏览器渲染原理](https://zhuanlan.zhihu.com/p/53913989)