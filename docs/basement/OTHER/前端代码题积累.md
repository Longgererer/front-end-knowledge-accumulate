# 前端面试题错题积累

> 这里记录着我在网上做错的一些面试题，在这里记一下防止忘记。

## 1.以下代码输出的结果为？

```js
var i = 0,
  timer,
  j = 0
while (i++ < 2) {
  timer = window.setTimeout(function () {
    j++
    alert(j)
  }, 500)
}

clearTimeout(timer)
```

答案：`500` 毫秒后，弹出一个 `alert` 框，内容为 `1`。

上述代码中定义了两个 `setTimeout`，因此，当 `500` 毫秒后，应当输出 `1` 和 `2`。

而执行完循环后，`timer` 所保存的是最后一个 `setTimeout` 的 `id`，因此 `clearTimeout(timer)` 将最后一个定时器取消了，所以只输出一个 `1`。

## 2. 在 HTML 中，（ ）可以在网页上通过链接直接打开邮件客户端发送邮件？

`< a href=”mailto:ming.zhou@nowcoder.com” >发送邮件< /a ><br>`

## 3. 以下代码输出结果为？

```js
var name = 1
;(function () {
  console.log(name + this.name) // browser: -> 'undefined1'; Node.js: -> NaN
  var name = '2'
  console.log(name + this.name) // browser: -> '21'; Node.js: -> '2undefined'
})()
```

在浏览器环境下 `name` 是 `window` 对象下的一个属性, 用 `var` 声明 `name` 为任意值, 都会将这个值转为 `string` 类型并更新 `window.name.` 因此在上述代码中, 一旦浏览器执行 `console.log(name + this.name);` 会输出 `'undefined1'`。但实际上在 `js` 中, 输入 `undefined + 1; // -> NaN`。

## 4. 【VDOM 模拟事件捕获机制】一个用数组存储的树, 查找树中的元素并输出查找路径?

```js
type TreeNode = { id: number, children?: TreeNode[] }
// 测试用例
const tree: TreeNode[] = [
  {
    id: 1,
    children: [{ id: 2 }, { id: 3 }],
  },
  {
    id: 5,
    children: [{ id: 6 }, { id: 7, children: [{ id: 10 }] }],
  },
]
// 大致思路: 用一个栈记录遍历路径
// 开始遍历一棵树时将树根 id 计入栈中
// 如果该子树整体无 target 节点, 则将该树根 id 出栈
const stack: number[] = []
/**
 * 查找一个树中是否有 target 节点的方法
 * 开始查找时, 先将树根入栈, 经过查找后, 若能查到 target, 则返回 true
 * 若没有查到, 则将栈顶元素出栈(栈顶元素定为树根), 并返回 false
 */
function findItem(tree: TreeNode[] | undefined, target: number): boolean {
  if (tree) {
    const index = tree.findIndex(({ id }) => id === target)
    if (index >= 0) {
      stack.push(arr[index].id)
      return true
    } else {
      for (let i = 0; i < arr.length; i++) {
        stack.push(tree[i].id)
        if (findItem(tree[i]?.children, target)) {
          return true
        } else {
          stack.pop()
        }
      }
      return false
    }
  } else {
    return false
  }
}
;(function () {
  findItem(tree, 10)
  console.log(stack) // -> [5, 7, 10]
})()
```

## 5. 实现 Promise.any

```js
Promise.any = function(arr) {
  return new Promise((resolve, reject) => {
    let res = [];
    let rejected = 0;
    const n = arr.length;
    for (let i in arr) {
      let promise = arr[i];
      if (!promise instanceOf Promise) {
        promise = Promise.resolve(promise);
      }
      promise.then(result => {
        resolve(result);
      }).catch(error => {
        rejected++;
        res[i] = error;
        if (rejected === n) reject(res);
      })
    }
  })
}
```

## 6. 以下代码的输出的结果为

```js
var a = 5
function todo() {
  var a = 9
  return function () {
    a = 7
  }
}
todo()()
console.log(a)
```

变量引用会沿着作用域链去查找，`todo()()` 之后改变的是 `todo` 作用域内部的 `a` 的值，由 9 变成 7，`console` 时候输出的是 `window` 下的 `a`，所以还是 5。

## 7. 如何使用 Proxy 实现简单 MVVM

```js
let onWatch = (obj, setBind, getLogger) => {
  let handler = {
    get(target, property, receiver) {
      getLogger(target, property)
      return Reflect.get(target, property, receiver)
    },
    set(target, property, value, receiver) {
      setBind(value, property)
      return Reflect.set(target, property, value)
    },
  }
  return new Proxy(obj, handler)
}
let obj = { a: 1 }
let p = onWatch(
  obj,
  (v, property) => {},
  (target, property) => {}
)
```

## 8. 实现一个观察者模式

```js
const createStore = (reducer, initState) => {
  let store = initState
  let listeners = []
  const getState = () => {
    return store
  }

  // 当执行dispatch更改状态操作时，store tree更新后，依次执行数组中的listener
  const dispatch = (action) => {
    store = reducer(store, action)
    listeners.foreach((listener) => {
      listener()
    })
  }

  // store内部维护listener数组，用于存储所有通过store.subscribe注册的listener
  // store.subscribe返回unsubscribe方法，用于注销当前listener
  const subscribe = (listener) => {
    listeners.push(listener)
    return () => {
      listeners = listeners.filter((item) => listener !== item)
    }
  }

  return {
    getState,
    dispatch,
    subscribe,
  }
}
```

## 9. 编写一个通用的柯里化函数 currying

```js
const currying = (fn) => {
  if (typeof fn !== 'function') {
    return new Error('No function provided')
  }
  return function curriedFn(...args) {
    if (args.length < fn.length) {
      return function () {
        return curriedFn.apply(null, args.concat([].slice.call(arguments)))
      }
    }
    return fn.apply(null, args)
  }
}
```

## 10. requestAnimationFrame 如何获取每秒的帧数？

## 11. 