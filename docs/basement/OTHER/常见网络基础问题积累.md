# 常见网络和优化基础问题积累

## 什么是跨域，什么是同源策略？

在前后端分离的模式下，前后端域名是不一致的，此时就会发生跨域访问的问题。

跨域问题来源于 JavaScript 的同源策略，只有协议，主机名和端口号都相同的情况下才允许互相访问，即使两个不同的域名指向同一个 ip 地址，也不是同源。对于其他的源，需要有明确授权的情况下才能读写对方的资源。

## 减少页面加载时间的方式

1. 减少 http 请求如：合并图片(csssprite，svgsprite)，合并文件。
2. 适当减小图片尺寸和清晰度。
3. 在浏览器支持的情况下使用 webp 在保留图片质量的同时减小图片体积。
4. 优化 CSS 代码：(合并重复 css，降低 css 选择器的复杂性等等)。
5. 将一些脚本样式和静态资源托管到 cdn。
6. 服务端启用 gzip 功能。浏览器再将 gzip 解压。
7. 减少 cookie 的体积，cookie 太多会拖慢请求速度。
8. 脚本使用 defer 或 async 延迟加载。

## 什么是 jsonp？

jsonp 就是 JSON width Padding 的略称，是民间提出的一种跨域解决方案，通过客户端的 script 标签发出的请求方式。

同源策略禁止我们使用脚本访问非同源下的资源，但通过一些标签发出的请求则不会被进行同源检查，如：script，link，img 标签。

实现过程如下：

1. 准备一个全局接收函数

```javascript
window.myCallback = (res) => {
  //声明一个全局函数 'callback'，用于接收响应数据
  console.log(res)
}
```

2. 在 html 创建 script 标签，发出请求

```html
<script>
  window.myCallback = (res) => {
    //声明一个全局函数 'callback'，用于接收响应数据
    console.log(res)
  }
</script>
<script url="xxx?callback=myCallback">
  // script标签的请求必须在写在定义全局函数之后
  // 这里需将全局函数的函数名作为参数callback的value传递
  // 这里callback这个键名是前后端约定好的
</script>
```

3. 服务端接收到请求，将如下数据响应回来

```javascript
myCallback({
  name: 'ahreal',
  age: 18,
})
```

最后我们就可以拿到请求的数据了。

注意这一步也是需要后台配合才可以的，并不是前端写这些代码就能实现的。

## HTTP 报文结构是怎样的？

报文大致结构是： `header` + `body`

具体点就是：**起始行 + 头部 + 空行 + 实体**

### 起始行

对于**请求报文**来说，起始行类似这样：`GET /home HTTP/1.1` 也就是 **方法 + 路径 + http 版本**。

对于**响应报文**来说，起始行一般是这个样：`HTTP/1.1 200 OK`。响应报文的起始行也叫做状态行。由 **http 版本、状态码和原因** 三部分组成。

### 空行

用来区分开头部和实体，**如果说在头部中间故意加一个空行，那么空行后的内容全部被视为实体。**

### 实体

表示具体的数据，请求报文对应请求体, 响应报文对应响应体。

## 如何理解 HTTP 的请求方法？

http/1.1 规定了以下请求方法：

- GET: 通常用来获取资源
- HEAD: 获取资源的元信息
- POST: 提交数据，即上传数据
- PUT: 修改数据
- DELETE: 删除资源(几乎用不到)
- CONNECT: 建立连接隧道，用于代理服务器
- OPTIONS: 列出可对资源实行的请求方法，用来跨域请求
- TRACE: 追踪请求-响应的传输路径

## GET 和 POST 有什么区别？

- 缓存：GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
- 编码：GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
- 参数：GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
- 幂等：在 RFC 文档中定义：GET 应该是幂等且安全的，而 POST 不是。

幂等表示：1-N 个相同请求的副作用与单个请求相同。

[RFC](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)

## 如何理解 URI？

URI，也就是统一资源标识符，它的作用很简单，就是区分互联网上不同的资源。

## 如何理解 HTTP 状态码？

RFC 规定 HTTP 的状态码为**三位数**，被分为五类:

- **1xx**: 表示目前是协议处理的中间状态，还需要后续操作。
  - **101 Switching Protocols**。在 HTTP 升级为 WebSocket 的时候，如果服务器同意变更，就会发送状态码 101。
- **2xx**: 表示成功状态。
  - **200 OK** 是见得最多的成功状态码。通常在响应体中放有数据。
  - **204 No Content** 含义与 200 相同，但响应头后没有 body 数据。
  - **206 Partial Content** 顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段 Content-Range。
- **3xx**: 重定向状态，资源位置发生变动，需要重新请求。
  - **301 Moved Permanently** 即永久重定向，比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回 301，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。
  - **302 Found** 临时重定向，如果网址只是暂时不可用，那么直接返回 302 即可，和 301 不同的是，浏览器并不会做缓存优化。
  - **304 Not Modified**: 当协商缓存命中时会返回这个状态码。
- **4xx**: 请求报文有误。
  - **400 Bad Request**: 开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了。
  - **401 Authentication Required**：表示拥护无权访问。
  - **403 Forbidden**: 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。
  - **404 Not Found**: 资源未找到，表示没在服务器上找到相应的资源。
  - **405 Method Not Allowed**: 请求方法不被服务器端允许。
  - **406 Not Acceptable**: 资源无法满足客户端的条件。
  - **408 Request Timeout**: 服务器等待了太长时间。
  - **409 Conflict**: 多个请求发生了冲突。
  - **413 Request Entity Too Large**: 请求体的数据过大。
  - **414 Request-URI Too Long**: 请求行里的 URI 太大。
  - **429 Too Many Request**: 客户端发送的请求过多。
  - **431 Request Header Fields Too Large**请求头的字段内容太大。
- **5xx**: 服务器端发生错误。
  - **500 Internal Server Error**: 仅仅告诉你服务器出错了，出了啥错咱也不知道。
  - **501 Not Implemented**: 表示客户端请求的功能还不支持。
  - **502 Bad Gateway**: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。
  - **503 Service Unavailable**: 表示服务器当前很忙，暂时无法响应服务。

## 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？

### 特点

- **灵活可扩展**：一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。
- **可靠传输**：HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。
- **请求-应答**：也就是一发一收、有来有回，一个请求对应一个应答。
- **无状态**：这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。

