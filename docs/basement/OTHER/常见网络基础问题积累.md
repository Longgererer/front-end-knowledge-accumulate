# 常见网络和优化基础问题积累

## 什么是跨域，什么是同源策略？

在前后端分离的模式下，前后端域名是不一致的，此时就会发生跨域访问的问题。

跨域问题来源于 JavaScript 的同源策略，只有协议，主机名和端口号都相同的情况下才允许互相访问，即使两个不同的域名指向同一个 ip 地址，也不是同源。对于其他的源，需要有明确授权的情况下才能读写对方的资源。

## 减少页面加载时间的方式

1. 减少 http 请求如：合并图片(csssprite，svgsprite)，合并文件。
2. 适当减小图片尺寸和清晰度。
3. 在浏览器支持的情况下使用 webp 在保留图片质量的同时减小图片体积。
4. 优化 CSS 代码：(合并重复 css，降低 css 选择器的复杂性等等)。
5. 将一些脚本样式和静态资源托管到 cdn。
6. 服务端启用 gzip 功能。浏览器再将 gzip 解压。
7. 减少 cookie 的体积，cookie 太多会拖慢请求速度。
8. 脚本使用 defer 或 async 延迟加载。
9. 服务器预渲染，适用于静态网站。

## 什么是 jsonp？

jsonp 就是 JSON width Padding 的略称，是民间提出的一种跨域解决方案，通过客户端的 script 标签发出的请求方式。

同源策略禁止我们使用脚本访问非同源下的资源，但通过一些标签发出的请求则不会被进行同源检查，如：script，link，img 标签。

实现过程如下：

1. 准备一个全局接收函数

```javascript
window.myCallback = (res) => {
  //声明一个全局函数 'callback'，用于接收响应数据
  console.log(res)
}
```

2. 在 html 创建 script 标签，发出请求

```html
<script>
  window.myCallback = (res) => {
    //声明一个全局函数 'callback'，用于接收响应数据
    console.log(res)
  }
</script>
<script url="xxx?callback=myCallback">
  // script标签的请求必须在写在定义全局函数之后
  // 这里需将全局函数的函数名作为参数callback的value传递
  // 这里callback这个键名是前后端约定好的
</script>
```

3. 服务端接收到请求，将如下数据响应回来

```javascript
myCallback({
  name: 'ahreal',
  age: 18,
})
```

最后我们就可以拿到请求的数据了。

注意这一步也是需要后台配合才可以的，并不是前端写这些代码就能实现的。

## HTTP 报文结构是怎样的？

报文大致结构是： `header` + `body`

具体点就是：**起始行 + 头部 + 空行 + 实体**

### 起始行

对于**请求报文**来说，起始行类似这样：`GET /home HTTP/1.1` 也就是 **方法 + 路径 + http 版本**。

对于**响应报文**来说，起始行一般是这个样：`HTTP/1.1 200 OK`。响应报文的起始行也叫做状态行。由 **http 版本、状态码和原因** 三部分组成。

### 空行

用来区分开头部和实体，**如果说在头部中间故意加一个空行，那么空行后的内容全部被视为实体。**

### 实体

表示具体的数据，请求报文对应请求体, 响应报文对应响应体。

## 如何理解 HTTP 的请求方法？

http/1.1 规定了以下请求方法：

- GET: 通常用来获取资源
- HEAD: 获取资源的元信息
- POST: 提交数据，即上传数据
- PUT: 修改数据
- DELETE: 删除资源(几乎用不到)
- CONNECT: 建立连接隧道，用于代理服务器
- OPTIONS: 列出可对资源实行的请求方法，用来跨域请求
- TRACE: 追踪请求-响应的传输路径

## GET 和 POST 有什么区别？

- 缓存：GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
- 编码：GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
- 参数：GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
- 幂等：在 RFC 文档中定义：GET 应该是幂等且安全的，而 POST 不是。

幂等表示：1-N 个相同请求的副作用与单个请求相同。

[RFC](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)

## 如何理解 URI？

URI，也就是统一资源标识符，它的作用很简单，就是区分互联网上不同的资源。

## 如何理解 HTTP 状态码？

RFC 规定 HTTP 的状态码为**三位数**，被分为五类:

- **1xx**: 表示目前是协议处理的中间状态，还需要后续操作。
  - **101 Switching Protocols**。在 HTTP 升级为 WebSocket 的时候，如果服务器同意变更，就会发送状态码 101。
- **2xx**: 表示成功状态。
  - **200 OK** 是见得最多的成功状态码。通常在响应体中放有数据。
  - **204 No Content** 含义与 200 相同，但响应头后没有 body 数据。
  - **206 Partial Content** 顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段 Content-Range。
- **3xx**: 重定向状态，资源位置发生变动，需要重新请求。
  - **301 Moved Permanently** 即永久重定向，比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回 301，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。
  - **302 Found** 临时重定向，如果网址只是暂时不可用，那么直接返回 302 即可，和 301 不同的是，浏览器并不会做缓存优化。
  - **304 Not Modified**: 当协商缓存命中时会返回这个状态码。
- **4xx**: 请求报文有误。
  - **400 Bad Request**: 开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了。
  - **401 Authentication Required**：表示拥护无权访问。
  - **403 Forbidden**: 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。
  - **404 Not Found**: 资源未找到，表示没在服务器上找到相应的资源。
  - **405 Method Not Allowed**: 请求方法不被服务器端允许。
  - **406 Not Acceptable**: 资源无法满足客户端的条件。
  - **408 Request Timeout**: 服务器等待了太长时间。
  - **409 Conflict**: 多个请求发生了冲突。
  - **413 Request Entity Too Large**: 请求体的数据过大。
  - **414 Request-URI Too Long**: 请求行里的 URI 太大。
  - **429 Too Many Request**: 客户端发送的请求过多。
  - **431 Request Header Fields Too Large**请求头的字段内容太大。
- **5xx**: 服务器端发生错误。
  - **500 Internal Server Error**: 仅仅告诉你服务器出错了，出了啥错咱也不知道。
  - **501 Not Implemented**: 表示客户端请求的功能还不支持。
  - **502 Bad Gateway**: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。
  - **503 Service Unavailable**: 表示服务器当前很忙，暂时无法响应服务。

## 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？

### 特点

- **灵活可扩展**：一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。
- **可靠传输**：HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。
- **请求-应答**：也就是一发一收、有来有回，一个请求对应一个应答。
- **无状态**：这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。

## 预加载和懒加载的区别

预加载指的是页面在加载完成后，提前将所需资源下载，之后使用的时候从缓存调用；懒加载是延迟加载，按照一定的条件或者需求等到满足条件的时候再加载对应的资源。

使用预加载，网页的加载速度将会非常快，适合大图很多的网站。而使用懒加载可以缓解服务器的压力。

## HTTP1.0/1.1/2.0 在并发请求上的主要区别是什么？

- **HTTP1.0**：**短连接**，每次 TCP 连接只对应一个请求，当服务器响应后，连接断开，下一个请求需要重新建立 TCP 连接。
- **HTTP1.1**：默认采用**长连接**，不用声明 `Connection: keep-alive`，增加了**管道**机制，在同一个 TCP 连接中允许多个请求同时发送，但是服务器需要**按照顺序一个一个响应**。**在同一个 TCP 连接中，所有的数据通信是按照顺序进行的**，如果一个请求响应慢，后面的请求都会被卡住，造成**队头堵塞**。
- **HTTP2.0**：加入了**双工模式**，不仅客户端能够同时发送多个请求，服务端也能同时处理多个请求。使用**多路复用**技术，同一个 TCP 连接可以并发处理多个请求。增加**服务器推送**，实现服务端主动向客户端发送数据的功能。

HTTP2 仍然没有解决队头堵塞问题，因为 HTTP2 会把一次传输所有的文件都放在一个 TCP 连接中，只要这个 TCP 中发生一个丢包，连接就必须重新建立，之前所有传输内容进行必须重传。

## 长连接和多路复用的区别？

**长连接**：**同一时间一个 TCP 连接只能够处理一个请求**，上一个请求响应后才能处理下一个请求。**浏览器有最大 TCP 连接数的限制，因此有最大并发请求数的限制**。

**多路复用**：**同域名下所有通信都在单个连接上完成**，消除了因为多个 TCP 连接而带来的延时和内存消耗。单个连接上可以并行交错的请求和响应，之间互不干扰。**并发请求的数量比长连接大了好几个量级**。

## 为什么 HTTP1.1 不能实现多路复用？

HTTP1.1 是基于**文本分割解析**的协议，而 HTTP2 是基于**二进制帧**的协议。

HTTP1.1 的报文结构中，服务器需要不断地读入字节，直到遇到换行符，或者说一个空白行；处理顺序的**串行**的，**一个请求和一个响应需要通过一问一答的形式才能连接起来**。

HTTP2.0 中存在**帧**和**流**两个概念。**帧代表最小数据单位，每个帧会标识出帧属于哪个流，流就是多个帧组成的数据流**。多路复用就是在一个 TCP 连接中可以存在多条流，也就是可以发送多个请求，两端可以通过帧中的标识知道该帧属于哪个流(请求)。

## 什么是 keep-alive

`Connection` 决定当前事务（一次三次握手和四次挥手）完成后，是否会关闭网络连接。

`Connection: keep-alive` 表示持久性连接，即一次事务完成后不关闭网络连接。

`Connection: close` 表示非持久性连接，即一次事务完成后关闭网络连接。

`keep-alive` 有两个参数，它们以逗号分隔，第一个表示空闲连接保持打开状态的最短时间(秒)，第二个表示关闭连接之前可以在次连接上发送的最大请求数：

```http
Connection: Keep-Alive
Keep-Alive: timeout=5, max=997
```

`keep-alive` 可以缓解 http1.0 短连接带来的效率问题，但仍有缺点：

- 串行的文件传输。
- 同域名下并行请求限制带来的阻塞(6-8)个。

## TCP 和 UDP 的区别

TCP **面向连接**协议，传输**可靠**，以**字节流**传输；传输**效率慢**，所需资源多；在场景要求通信数据可靠的请况下使用如文件传输，邮件发送等。报文首部字节 20-60。TCP 保证数据传输的顺序和正确性。

UDP **无连接**协议，传输**不可靠**，以**数据报文段**传输；传输**效率快**，所需资源少；在对通信速度要求高的场景下使用如域名转换，视频音频等。报文首部 9 个字节。UDP 不保证数据传输的顺序和正确性。

## 什么是 QUIC？QUIC 基于 UDP 怎么保证可靠性？

QUIC（Quick UDP Internet Connections）是 Google 基于 UDP 提出的一种改进的通信协议。也称为 HTTP3.0。

QUIC 使用 UDP 来传输数据以加快网络速度，降低延迟，由 QUIC 来保证数据的顺序、完整性和正确性，即使发生了丢包，也由 QUIC 来负责数据的**纠错**。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e41fd25a3c2242bfaf58b918326e4645~tplv-k3u1fbpfcp-watermark.awebp)

QUIC 集成了 TCP + HTTPS + HTTP/2 的功能，QUIC 连接基于 Diffie-Hellman 的加密算法。

## 预渲染和 SSR 的区别

用户请求前的服务器渲染即为「预渲染」。一般用于静态站点。预渲染是直接返回给浏览器真正 html 页面，因此不会执行里面的 js 脚本。

用户请求后的服务器渲染即为「服务端渲染」，需要经过解析执行 JS => 构建 HTML 页面 => 输出给浏览器。

## CSR 和 SSR 的优缺点

服务端渲染的优缺点：

- 前端页面加载快，只负责渲染。
- 有利于网站的 SEO，后端有完整的 html 页面，所以爬虫更容易爬取获得信息。
- 不利于前后端分离，开发效率低。
- 占用服务器端资源。

客户端渲染的优缺点：

- 有利于前后端分离。
- SAP 的页面切换体验更好。
- 首屏加载慢，需要许多优化。
- 不利于 SEO。

## 什么是 gRPC？gRPC 相比 http(Restful API) 的优势？

gRPC 是一个高性能开源 RPC 框架。

RPC(remote procedure call 远程过程调用)框架实际是提供了一套机制，**使得应用程序之间可以进行通信，而且也遵从 server/client 模型**。使用的时候客户端调用 server 端提供的接口就像是调用本地的函数一样。

和 Restful API 一样，gRPC 也使用 http 作为底层传输协议。但 gRPC 使用的 **http2.0**，而 restful api 则不一定。

- gRPC 可以通过 **protobuf** 来定义接口，可以有**更加严格的接口约束条件**，支持多种语言。
- protobuf 可以将**数据序列化为二进制编码**，这会大幅减少需要传输的数据量，从而大幅**提高传输速度**。
- gRPC 可以支持 **streaming 流式通信（http2.0）**，提高传输速度。

## DNS 预解析是什么？有什么用？

DNS 解析时间可能导致大量用户感知延迟，DNS 预解析可以减少这种情况的发生。

浏览器对网站第一次的域名 DNS 解析查找流程依次为：**浏览器缓存**-**系统缓存**-**路由器缓存**-**ISP** **DNS 缓存**-**递归搜索**。

DNS 预解析是浏览器试图在用户访问链接之前解析域名。域名解析后，如果用户确实访问该域名，那么 DNS 解析时间将不会有延迟。

遇到网页中的超链接，**DNS prefetching** 从中提取域名并将其解析为 IP 地址，这些工作在用户浏览网页时，使用最少的 CPU 和网络在后台进行解析。

在某些浏览器中这个预读取的行为将会与页面实际内容并行发生（而不是串行）。正因如此，某些高延迟的域名的解析过程才不会卡住资源的加载。

你可以通过在服务器端发送 `X-DNS-Prefetch-Control` 报头，或是在文档中使用值为 `http-equiv` 的标签。

```html
<meta http-equiv="x-dns-prefetch-control" content="off" />
```

你可以通过使用 `rel` 属性值为 `link type` 中的 `dns-prefetch` 的标签来**对特定域名进行预读取**：

```html
<link rel="dns-prefetch" href="http://www.xuanfengge.com/" />
```

Chrome 会记住最近使用的 10 个 domain，并且在开启浏览器时自动解析，因此在打开这些常用页面的时候，并不会有 DNS Lookup 的延迟情况。

chrome 使用 8 个线程专门做 DNS Prefetching，而且 chrome 本身不做 dns 记录的 cache，是直接从操作系统读 dns。所以直接修改系统的 dns 记录或者 host 是可以直接影响 chrome。

## A，B 机器正常连接后，B 突然重启，A 此时处于 TCP 什么状态？

B 会在重启之后进入 TCP 的 listen 状态，只要 A 重新发送数据包，不管是什么包，B 应该会主动发送一个带有 RST 位的重置包进行连接重置，所以 A 应该在 SYN_SENT 状态。

![](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/KfGu3WwVIa36iaZtiahkjpa1Qyx0Gz3P6FPJsUPf5TAib6jt5jbMD8Uwm7BlmCBnasgU9vXRc2HlmP5HDcSiapODFw/640?wx_fmt=jpeg)

## Chrome 可以并行下载多少个资源？

6 个，同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。大多数浏览器的并发数量都控制在 6 以内。有些资源的请求时间很长，因而会阻塞其他资源的请求。因此，对于一些静态资源，如果放到不同的域名下面就能实现与其他资源的并发请求。

## webSocket 如何兼容低浏览器？

使用轮询或长连接的方式实现伪 websocket 的通信。

## 长轮询和短轮询的区别？

长轮询是服务器收到请求后如果有数据, 立刻响应请求; 如果没有数据就会 hold 一段时间,这段时间内如果有数据立刻响应请求; 如果时间到了还没有数据, 则响应 http 请求;浏览器受到 http 响应后立即发送一个同样 http 请求查询是否有数据。

短轮询是服务器收到请求不管是否有数据都直接响应 http 请求; 浏览器受到 http 响应隔一段时间在发送同样的 http 请求查询是否有数据;

## Web 应用从服务器主动推送数据到客户端有哪些方式？

1. 短轮询，利用 setInterval 定时像服务器发送请求。
2. 长轮询，在后端数据没有更新的时候不再返回空响应，而且后端一直保存连接，直到后端有数据变化，则相应请求并且关闭连接，前端收到数据，马上再次向后端发起请求，并处理刚刚收到的数据。
3. WebSocket 真正意义上的主动推送。

## 304 缓存原理？

服务器首先产生 ETag，ETag 一般为资源的哈希值，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端将该记号通过 If-None-Match 传回服务器要求服务器验证其（客户端）缓存。

304 是 HTTP 状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件

