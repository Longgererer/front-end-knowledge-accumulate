# 简单难度

## 1. 两数求和

给定一个整数数组 `nums`  和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target`的那两个整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
function twoSum(nums, target) {
  const lastNum = nums.pop()
  for (let i = 0; i < nums.length; i++) {
    const currentNum = nums[i]
    if (currentNum + lastNum === target) {
      return [i, nums.length]
    }
  }
  return twoSum(nums, target)
}
```

## 2. 整数反转

给你一个 `32` 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。

如果反转后整数超过 `32` 位的有符号整数的范围 `[−231, 231 − 1]`，就返回 `0`。

假设环境不允许存储 `64` 位整数（有符号或无符号）。

```js
/**
 * @param {number} x
 * @return {number}
 */
function reverse(x) {
  const strArr = String(x).split('')
  let isNegative = strArr[0] === '-'
  if (isNegative) strArr.shift()
  const num = Number(
    strArr
      .map((item) => Number(item))
      .reverse()
      .join('')
  )
  if (!isNegative && num < 2 ** 31) {
    return num
  } else if (-num > -(2 ** 31)) {
    return -num
  }
  return 0
}
```

## 3. 回文数

给你一个整数 `x`，如果 `x` 是一个回文整数，返回 `true`，否则，返回 `false`。

你能不将整数转为字符串来解决这个问题吗？

不用转换字符串：

```js
/**
 * @param {number} x
 * @return {boolean}
 */
function isPalindrome(x) {
  if (x === 0) return true
  else if (x < 0 || x % 10 === 0) return false
  else {
    const len = (x + '').length
    let halfLen = parseInt(len / 2)
    let posNumArr = []
    for (let i = 1; i <= len; i++) {
      posNumArr.push(parseInt(0 | ((x % 10 ** i) / 10 ** (i - 1))))
      if (i > len - halfLen) {
        if (posNumArr[i - 1] !== posNumArr[len - i]) {
          return false
        }
      }
    }
  }
  return true
}
```

转换成字符串：

```js
/**
 * @param {number} x
 * @return {boolean}
 */
function isPalindrome(x) {
  return (
    x
      .toString()
      .split('')
      .reverse()
      .join('') === x.toString()
  )
}
```

## 4. 罗马数字转整数

罗马数字包含以下七种字符: `I`，`V`，`X`，`L`，`C`，`D` 和 `M`。

```bash
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 `2` 写做  `II` ，即为两个并列的 `1`。`12` 写做  `XII`，即为  `X` + `II` 。 `27` 写做  `XXVII`, 即为  `XX + V + II`。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 `4` 不写做 `IIII`，而是 `IV`。数字 `1` 在数字 `5` 的左边，所表示的数等于大数 5 减小数 `1` 得到的数值 `4` 。同样地，数字 `9` 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

`I` 可以放在 `V(5)` 和 `X(10)` 的左边，来表示 `4` 和 `9`。
`X` 可以放在 `L(50)` 和 `C(100)` 的左边，来表示 `40` 和 `90`。
`C` 可以放在 `D(500)` 和 `M(1000)` 的左边，来表示 `400` 和 `900`。
给定一个罗马数字，将其转换成整数。输入确保在 `1` 到 `3999` 的范围内。

```js
/**
 * @param {string} s
 * @return {number}
 */
function romanToInt(s) {
  let cursor = 1
  let len = s.length
  let sum = 0
  while (cursor <= len) {
    let char = s[cursor - 1]
    switch (char) {
      case 'I': {
        sum++
        break
      }
      case 'V': {
        sum += cursor > 1 && s[cursor - 2] === 'I' ? 3 : 5
        break
      }
      case 'X': {
        sum += cursor > 1 && s[cursor - 2] === 'I' ? 8 : 10
        break
      }
      case 'L': {
        sum += cursor > 1 && s[cursor - 2] === 'X' ? 30 : 50
        break
      }
      case 'C': {
        sum += cursor > 1 && s[cursor - 2] === 'X' ? 80 : 100
        break
      }
      case 'D': {
        sum += cursor > 1 && s[cursor - 2] === 'C' ? 300 : 500
        break
      }
      case 'M': {
        sum += cursor > 1 && s[cursor - 2] === 'C' ? 800 : 1000
        break
      }
    }
    cursor++
  }
  return sum
}
```
