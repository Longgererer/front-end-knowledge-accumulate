# 简单难度

## 1. 两数求和

给定一个整数数组 `nums`  和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target`的那两个整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
function twoSum(nums, target) {
  const lastNum = nums.pop()
  for (let i = 0; i < nums.length; i++) {
    const currentNum = nums[i]
    if (currentNum + lastNum === target) {
      return [i, nums.length]
    }
  }
  return twoSum(nums, target)
}
```

## 2. 整数反转

给你一个 `32` 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。

如果反转后整数超过 `32` 位的有符号整数的范围 `[−231, 231 − 1]`，就返回 `0`。

假设环境不允许存储 `64` 位整数（有符号或无符号）。

```js
/**
 * @param {number} x
 * @return {number}
 */
function reverse(x) {
  const strArr = String(x).split('')
  let isNegative = strArr[0] === '-'
  if (isNegative) strArr.shift()
  const num = Number(
    strArr
      .map((item) => Number(item))
      .reverse()
      .join('')
  )
  if (!isNegative && num < 2 ** 31) {
    return num
  } else if (-num > -(2 ** 31)) {
    return -num
  }
  return 0
}
```

## 3. 回文数

给你一个整数 `x`，如果 `x` 是一个回文整数，返回 `true`，否则，返回 `false`。

你能不将整数转为字符串来解决这个问题吗？

不用转换字符串：

```js
/**
 * @param {number} x
 * @return {boolean}
 */
function isPalindrome(x) {
  if (x === 0) return true
  else if (x < 0 || x % 10 === 0) return false
  else {
    const len = (x + '').length
    let halfLen = parseInt(len / 2)
    let posNumArr = []
    for (let i = 1; i <= len; i++) {
      posNumArr.push(parseInt(0 | ((x % 10 ** i) / 10 ** (i - 1))))
      if (i > len - halfLen) {
        if (posNumArr[i - 1] !== posNumArr[len - i]) {
          return false
        }
      }
    }
  }
  return true
}
```

转换成字符串：

```js
/**
 * @param {number} x
 * @return {boolean}
 */
function isPalindrome(x) {
  return (
    x
      .toString()
      .split('')
      .reverse()
      .join('') === x.toString()
  )
}
```

## 4. 罗马数字转整数

罗马数字包含以下七种字符: `I`，`V`，`X`，`L`，`C`，`D` 和 `M`。

```bash
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 `2` 写做  `II` ，即为两个并列的 `1`。`12` 写做  `XII`，即为  `X` + `II` 。 `27` 写做  `XXVII`, 即为  `XX + V + II`。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 `4` 不写做 `IIII`，而是 `IV`。数字 `1` 在数字 `5` 的左边，所表示的数等于大数 5 减小数 `1` 得到的数值 `4` 。同样地，数字 `9` 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

`I`  可以放在 `V(5)` 和 `X(10)` 的左边，来表示 `4` 和 `9`。
`X`  可以放在 `L(50)` 和 `C(100)` 的左边，来表示 `40` 和 `90`。
`C`  可以放在 `D(500)` 和 `M(1000)` 的左边，来表示 `400` 和 `900`。
给定一个罗马数字，将其转换成整数。输入确保在 `1`  到 `3999` 的范围内。

```js
/**
 * @param {string} s
 * @return {number}
 */
function romanToInt(s) {
  let cursor = 1
  let len = s.length
  let sum = 0
  while (cursor <= len) {
    let char = s[cursor - 1]
    switch (char) {
      case 'I': {
        sum++
        break
      }
      case 'V': {
        sum += cursor > 1 && s[cursor - 2] === 'I' ? 3 : 5
        break
      }
      case 'X': {
        sum += cursor > 1 && s[cursor - 2] === 'I' ? 8 : 10
        break
      }
      case 'L': {
        sum += cursor > 1 && s[cursor - 2] === 'X' ? 30 : 50
        break
      }
      case 'C': {
        sum += cursor > 1 && s[cursor - 2] === 'X' ? 80 : 100
        break
      }
      case 'D': {
        sum += cursor > 1 && s[cursor - 2] === 'C' ? 300 : 500
        break
      }
      case 'M': {
        sum += cursor > 1 && s[cursor - 2] === 'C' ? 800 : 1000
        break
      }
    }
    cursor++
  }
  return sum
}
```

## 5. 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
function longestCommonPrefix(strs) {
  const len = strs.length
  if (len === 0) return ''
  else if (len === 1) return strs[0]
  else {
    let minStr = strs[0]
    let maxStr = strs[0]
    let commonPre = ''
    for (let i = 1; i < len; i++) {
      const current = strs[i]
      if (current > maxStr) {
        maxStr = current
      } else if (current < minStr) {
        minStr = current
      }
    }
    for (let i = 0; i < minStr.length; i++) {
      if (minStr[i] === maxStr[i]) {
        commonPre += minStr[i]
      } else {
        break
      }
    }
    return commonPre
  }
}
```

## 6. 有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'`  的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
  let len = s.length
  for (let i = 0; i < len; i++) {
    s = s
      .replace('()', '')
      .replace('[]', '')
      .replace('{}', '')
    if (s === '') break
  }
  return s === ''
}
```

## 7. 合并两个有序链表

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

如：

```bash
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]

输入：l1 = [], l2 = [0]
输出：[0]

输入：l1 = [], l2 = []
输出：[]
```

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
function mergeTwoLists(l1, l2) {
  let cursor = new ListNode()
  let head = cursor
  while (l1 && l2) {
    if (l1.val <= l2.val) {
      cursor.next = l1
      l1 = l1.next
    } else {
      cursor.next = l2
      l2 = l2.next
    }
    cursor = cursor.next
  }
  if (!l1) cursor.next = l2
  if (!l2) cursor.next = l1
  return head.next
}
```

## 8. 删除有序数组中的重复项

数组 `nums` 是升序的，请你在空间复杂度为 $O(1)$ 的情况下将数组中重复的项删除，并返回数组的新长度。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
function removeDuplicates(nums) {
  if (!nums.length) return 0
  let newLen = 1
  for (let i = 1; i < nums.length; i++) {
    if (nums[i] === nums[i - 1]) {
      continue
    } else {
      nums[newLen] = nums[i]
      newLen++
    }
  }
  return newLen
}
```

## 9. 主要元素

数组中占比超过一半的元素称之为主要元素。给你一个整数数组，找出其中的主要元素。若没有，返回 `-1` 。请设计时间复杂度为 $O(N)$ 、空间复杂度为 $O(1)$ 的解决方案。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
function majorityElement(numArr) {
  let num,
    count = 0
  for (let i = 0; i < numArr.length; i++) {
    if (count === 0) {
      num = numArr[i]
      count = 1
    } else if (num === numArr[i]) {
      ++count
    } else {
      --count
    }
  }
  // 进行判断，验证最后剩下的数出现次数是不是真的超过数组的一半
  count = 0
  for (let i = 0; i < numArr.length; i++) {
    if (numArr[i] === num) ++count
  }
  return count > parseInt(numArr.length / 2) ? num : -1
}
```

## 10. 移除元素

给你一个数组 `nums`  和一个值 `val`，你需要 原地 移除所有数值等于  `val`  的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 $O(1)$ 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

```js
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
function removeElement(nums, val) {
  let newLen = 0
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== val) {
      nums[newLen] = nums[i]
      newLen++
    }
  }
  return newLen
}
```

### 11. 搜索插入位置

给定一个升序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 $O(log n)$ 的算法。

使用二分法：

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
function searchInsert(nums, target) {
  let start = 0,
    end = nums.length
  if (start === end) return 0
  if (target <= nums[start]) return start
  if (target >= nums[end]) return end
  while (start <= end) {
    const half = Math.floor((start + end) / 2)
    const midNum = nums[half]
    if (target === midNum) return half
    if (target > midNum) {
      start = half + 1
    } else {
      if (end >= 1 && target > nums[half - 1]) {
        return half
      }
      end = half - 1
    }
  }
}
```
