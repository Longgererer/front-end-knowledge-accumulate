# 字符串匹配算法

## 朴素解法

朴素解法是最简单易懂的：

枚举字符串中的每个字符作为**发起点**，每次**将发起点和匹配字符串的首位进行比较**。

- 匹配成功：返回发起点。
- 匹配失败：枚举字符串中下一个发起点，重新尝试匹配。

```js
function strStr(s, p) {
  const n = s.length,
    m = p.length
  for (let i = 0; i <= n - m; i++) {
    let cpyI = i,
      cur = 0
    while (k < m && s[cpyI] === p[cur]) {
      cpyI++
      cur++
    }
    if (k === m) return i
  }
  return -1
}
```

该算法时间复杂度为 $O((n-m)*m)$，空间复杂度为 $O(1)$。

## KMP 算法

KMP 算法与朴素解法不同，KMP 是通过非完全匹配提取有效信息，减少重复匹配的消耗。

朴素解法在匹配失败的情况下会调整到下一个发起点进行匹配，而 KMP 算法在匹配失败的情况下是这样的：

匹配字符串会检查之前已经匹配成功的部分中是否有**相同的前缀和后缀**，如果有，则跳转到**前缀的下个位置**继续匹配。

例如：原字符串为 `ississmissp`，匹配字符串为 `issp`。

```bash
第一次匹配，前三个字符匹配，第四个不匹配：

i s s i s s m i s s p
| | | ×
i s s p

检查共同前缀和后缀，发现前三个字符iss为共同前缀，因此直接跳过这三个字符，从第四个字符开始比较：

i s s i s s m i s s p
      | | | ×
      i s s p

不匹配，但有共同前缀，因此跳过共同前缀：

i s s i s s m i s s p
            ×
            i s s p

第一个字符就不匹配，但发现后缀iss匹配，因此跳到下一个位置：

i s s i s s m i s s p
              | | | |
              i s s p

匹配，完成搜索。
```

KMP 利用已匹配部分的共同前缀和后缀加速下一次的匹配，因此比朴素解法更快。

然而相对于朴素算法，我们需要在每次匹配之后找出共同前缀和后缀，这一步该怎么办？

我们可以看出**从匹配字符串的某个位置跳转到下一个匹配位置这个过程与原字符串是无关的。**

因此我们可以定义一个 `next` 数组，数组中存放着应该跳转的目标位置。

假设有匹配字符串 `aaabbab`，`next` 数组的变化如下：

![](https://pic.leetcode-cn.com/1618846927-xFAEXE-010FD8AE2B79FFE03DC3735ACD224A6A.png)

![](https://pic.leetcode-cn.com/1618847960-lkVIDM-B9497542844478144BED83E9ADA0C12F.png)

![](https://pic.leetcode-cn.com/1618847981-wncoqJ-161584A2D930A7B91092A2C3872D9DE5.png)

![](https://pic.leetcode-cn.com/1618847995-vRWimV-6127EBA37435560C20BB8B15D5B790B6.png)

下面是 KMP 算法的实现：

```js
```

## BM 算法

## Sunday 算法

KMP 理解起来真是不慎麻烦，还是看看理解难度较低的 Sunday 算法吧。

Sunday 算法关注的是原字符串中**参与匹配的最末字符（并非正在匹配的）的下一位**。

Sunday 算法的策略就是：

1. 当遇到不匹配的字符时，如果**关注的字符**没有在**模式串**中出现，则直接跳过。

```bash
原字符串 a b c d a b d e f h a b e
　　　　 | | ×
模式串　 a b e
```

模式串 `abe` 中并不存在字符 `d`，因此需要移动 `模式串.length + 1 = 4`。

2. 当遇到不匹配字符时，如果**关注的字符**在**模式串**中存在，其移动位数就是 `模式串.length - 该字符最右出现的位置(从0开始)`。

```bash
原字符串 a b c d a b d e f h a b e
　　　　               ×
模式串　               a b e
```

在这个例子中，参与匹配的最末字符的下一位为 `a`，`a` 在模式串中存在，则移动 `模式串.length - 0 = 3`。

在举个例子：`ississpississmp` 和 `ississm`。

首先算出**模式串**中所有字符的**偏移量**：

```bash
i -> 4, s -> 2, m -> 1
```

进行第一次比较

```bash
原字符串 i s s i s s p i s s i s s m p
　　　　 | | | | | | ×
模式串　 i s s i s s m
```

最后一位不匹配，查看参与匹配的最末字符的下一位 `i` 在偏移表中的偏移量为 `4`，于是模式串向右移动 `4` 位，再次进行比较：

```bash
原字符串 i s s i s s p i s s i s s m p
　　　　         ×
模式串　         i s s i s s m
```

第一个位不匹配，查看参与匹配的最末字符的下一位 `s` 在偏移表中对应的偏移量为 `2`，于是模式串向右移动 `2` 位，再次进行比较：

```bash
原字符串 i s s i s s p i s s i s s m p
　　　　             ×
模式串　             i s s i s s m
```

第一个位不匹配，查看参与匹配的最末字符的下一位 `m` 在偏移表中对应的偏移量为 `1`，于是模式串向右移动 `1` 位，再次进行比较：

```bash
原字符串 i s s i s s p i s s i s s m p
　　　　               | | | | | | |
模式串　               i s s i s s m
```

匹配成功。

Sunday 的示例代码：

```js
function sundaySearch(haystack, needle) {
  if (needle === '') return 0
  // 存放偏移量的对象(用Map也可以)
  const offset = {}
  const hLen = haystack.length
  const nLen = needle.length
  // 遍历needle计算偏移量
  for (let i = 0; i < nLen; i++) {
    offset[needle[i]] = nLen - i
  }

  let j,
    i = 0
  while (i <= hLen - nLen) {
    j = 0
    // 依次匹配字符
    while (haystack[i + j] === needle[j]) {
      j++
      // 全部匹配返回i
      if (j === nLen) return i
    }
    // 全部不匹配返回-1
    if (i + nLen === hLen) return -1
    // 参与匹配的最末字符的下一位是否存在于模式串中
    if (offset.hasOwnProperty(haystack[i + nLen])) {
      // 存在，i就跳到偏移表中当前字符
      i += offset[haystack[i + nLen]]
    } else {
      // 不存在，i就跳过下一位
      i += nLen + 1
    }
  }
  return -1
}
```

## 参考文章

- [算法之字符串模式匹配](https://zhuanlan.zhihu.com/p/24649304)
- [【宫水三叶】简单题学 KMP 算法](https://leetcode-cn.com/problems/implement-strstr/solution/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/)
- [Sunday 解法](https://leetcode-cn.com/problems/implement-strstr/solution/python3-sundayjie-fa-9996-by-tes/)
- [字符串匹配 - Sunday 算法](https://www.jianshu.com/p/a3f8d72c8405)
